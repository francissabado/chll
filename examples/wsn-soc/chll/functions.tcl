#! flowproc, yosys, trfsmgen
# 
# TCL help functions, partly specific to tools
#

# helper procedure to copy the template to the active file
proc CopyTemplate {Filename} {
  # cut off trailing '.tpl'
  set DstName [string range "$Filename" 0 [expr [string length "$Filename"] - 5]]
  if {[file exists $DstName]} {
    return
  }
  file copy "$Filename" "$DstName"
}

# trfsmgen helper procedure to create TRFSM Wrappers
# ./units/reconfmodule/chll/scripts/setup-trfsms.tcl does a very similar job,
# but doesn't directly write files
proc CreateWrappers {TRFSMs TRFSMShortNames FileBase} {
  set Wrappers [list]
  for {set Idx 0} {$Idx < [llength $TRFSMs]} {incr Idx} {
    set TRFSM       [lindex $TRFSMs          $Idx]
    set ShortName   [lindex $TRFSMShortNames $Idx]
    set ShortNameLC [string tolower $ShortName]
    # create wrapper module for TR-FSM
    set Wrapper [create_trfsm_wrapper $TRFSM $ShortName]
    lappend Wrappers $Wrapper
    # write to file
    write_trfsm_wrapper $Wrapper -format vhdl    "${FileBase}${ShortNameLC}-wrapper.vhd"
    write_trfsm_wrapper $Wrapper -format verilog "${FileBase}${ShortNameLC}-wrapper.v"
    write_trfsm_wrapper $Wrapper -format ilang   "${FileBase}${ShortNameLC}-wrapper.il"
  }
  return $Wrappers
}

# helper procedure to create a verilog module looking at deep hierarchical signals
proc WriteExtNames {ExtNamesArr Filename Module Prefix} {
  # create Verilog file
  puts "## Creating Verilog module to access internal signals from testbench as $Filename"
  set f [open $Filename "w"]
  puts $f "// Access internal signals from testbench"
  puts $f "// Auto-generated by [info script]"
  puts $f ""
  puts $f "module $Module ("
  set i 0
  upvar "$ExtNamesArr" ExtNames
  foreach {ExtName RegEx} [array get ExtNames] {
    set signal [app_get_signal -regex $RegEx]
    set width  [app_get_signal $signal -width]
    # vector specification
    if { $width == 1 } {
      set vector ""
    } else {
      set msb [expr $width - 1]
      set vector "\[$msb:0\]"
    }
    # comma at the end of line
    if { $i < [expr [array size ExtNames] - 1]} {
      set comma ","
    } else {
      set comma ""   ;# the last one doesn't get a comma
    }
    incr i
    puts $f "  output$vector $ExtName$comma"
  }
  puts $f ");"
  foreach {ExtName RegEx} [array get ExtNames] {
    set signal [app_get_signal -regex $RegEx]
    set driver [app_get_signal $signal -driver]
    if {[llength $driver] == 1} {
      # module input, search for sinks instead of driver
      set driver [app_get_signal $signal -anysink]
    }
    # driver is now ["instance" "port"]
    set inst [lindex $driver 0]
    set port [lindex $driver 1]
    set isinst [app_get_intersynth_instance $inst]
    puts "$ExtName = $signal --> $isinst.$port"
    puts $f "  assign $ExtName = ${Prefix}.$isinst.$port;"
  }
  puts $f "endmodule"
  close $f
}
