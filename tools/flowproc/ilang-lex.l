(*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Clifford Wolf <clifford@clifford.at>
 *  
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  A very simple and straightforward frontend for the RTLIL text
 *  representation (as generated by the 'ilang' backend).
 *
 *)

// %option yylineno
// %option noyywrap
// %option nounput
// %option prefix="rtlil_frontend_ilang_yy"

%{
Function ParseString(St:AnsiString):AnsiString;
Var PI,PO : Integer;
    Ch    : Char;
Begin
  PI := 2;   // skip leading '"'
  PO := 1;
  SetLength(Result,Length(St));
  While PI < Length(St) do  // skip trailing '"'
    Begin
      Ch := St[PI];
      Inc(PI);
      if Ch = '\' then
        Begin
          if      St[PI] = 'n' then Ch := ^J
          else if St[PI] = 't' then Ch := ^I 
          else if St[PI] in ['0'..'7'] then
            Begin
              // '\123'  <-- octal number
              Ch := Chr(((Ord(St[PI  ]) - Ord('0')) shl 6) or
                        ((Ord(St[PI+1]) - Ord('0')) shl 3) or
                        ((Ord(St[PI+2]) - Ord('0'))      ));
              Inc(PI,2);
            End
          else
            Ch := St[PI];
          Inc(PI);
        End;
      Result[PO] := Ch;
      Inc(PO);
    End;
  SetLength(Result,PO-1);
End;
%}

%%

"autoidx"       return(TOK_AUTOIDX);
"module"	return(TOK_MODULE);
"attribute"	return(TOK_ATTRIBUTE);
"parameter"	return(TOK_PARAMETER);
"signed"	return(TOK_SIGNED);
"wire"		return(TOK_WIRE);
"memory"	return(TOK_MEMORY);
"width"		return(TOK_WIDTH);
"offset"	return(TOK_OFFSET);
"size"		return(TOK_SIZE);
"input"		return(TOK_INPUT);
"output"	return(TOK_OUTPUT);
"inout"		return(TOK_INOUT);
"cell"		return(TOK_CELL);
"connect"	return(TOK_CONNECT);
"switch"	return(TOK_SWITCH);
"case"		return(TOK_CASE);
"assign"	return(TOK_ASSIGN);
"sync"		return(TOK_SYNC);
"low"		return(TOK_LOW);
"high"		return(TOK_HIGH);
"posedge"	return(TOK_POSEDGE);
"negedge"	return(TOK_NEGEDGE);
"edge"		return(TOK_EDGE);
"always"	return(TOK_ALWAYS);
"init"		return(TOK_INIT);
"update"	return(TOK_UPDATE);
"process"	return(TOK_PROCESS);
"end"		return(TOK_END);

[a-z]+		return(TOK_INVALID);

%{
(* All Yosys internal identifiers either start with '\' or '$'. '\'-identifiers
 * are from the input HDL, while '$'-identifiers are internally generated
 * names. To match the original HDL code, we strip of the '\' but not the '$'.
 *)
%}
"\\"[^ \t\r\n]+		Begin yylval.yyTValueString := TValueString.Create(Copy(yytext,2,Length(yytext))); return(TOK_ID); End;
"$"[^ \t\r\n]+		Begin yylval.yyTValueString := TValueString.Create(yytext); return(TOK_ID); End;
"."[0-9]+		Begin yylval.yyTValueString := TValueString.Create(yytext); return(TOK_ID); End;

[0-9]+'[01xzm-]*	Begin yylval.yyTValueString := TValueString.Create(yytext); return(TOK_VALUE); End;
[0-9]+			Begin yylval.yyinteger := StrToInt(yytext);       return(TOK_INT); End;

\"(\\.|[^"])*\"         Begin
    //WriteLn('Single-Rule String in line ',yylineno,': +',yytext,'+');
    yylval.yyTValueString := TValueString.Create(ParseString(yytext));
    return(TOK_STRING);
  End;
%{
(*
\"		Begin
  WriteLn('Start of string');

<scSTRING>\\.	Begin WriteLn('inside the string'); yymore(); End;
<scSTRING>\"	Begin
        WriteLn('End of String: yytext = +',yytext,'+');
	START(0);
	char *yystr = strdup(yytext);
	yystr[strlen(yytext) - 1] = 0;
	int i = 0, j = 0;
	while (yystr[i]) Begin
		if (yystr[i] == '\\' && yystr[i + 1]) Begin
			i++;
			if (yystr[i] == 'n')
				yystr[i] = '\n';
			else if (yystr[i] == 't')
				yystr[i] = '\t';
			else if ('0' <= yystr[i] && yystr[i] <= '7') Begin
				yystr[i] = yystr[i] - '0';
				if ('0' <= yystr[i + 1] && yystr[i + 1] <= '7') Begin
					yystr[i + 1] = yystr[i] * 8 + yystr[i + 1] - '0';
					i++;
				End;
				if ('0' <= yystr[i + 1] && yystr[i + 1] <= '7') Begin
					yystr[i + 1] = yystr[i] * 8 + yystr[i + 1] - '0';
					i++;
				End;
			End;
		End;
		yystr[j++] = yystr[i++];
	End;
	yystr[j] = 0;
	yylval.yyshortstring := yystr;
	return(TOK_STRING);
  End;
<scSTRING>.	Begin yymore(); End;
*)
%}

"#"[^\n]*\n	; (* ignore comments *)
[ \t]		; (* ignore non-newline whitespaces *)
[\r\n]+		return(TOK_EOL);

.               returnc(yytext[1]);

%%

