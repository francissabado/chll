/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2012  Clifford Wolf <clifford@clifford.at>
 *  
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  ---
 *
 *  A very simple and straightforward frontend for the RTLIL text
 *  representation (as generated by the 'ilang' backend).
 *
 */

%{

Type
  TWireOptions = object
    AutoWidth : Boolean;
    Width     : Integer;
    Offset    : Integer;
    PortId    : Integer;   // -1: normal signal
    Dir       : TPortDirection;
    Procedure Reset;
  End;

Procedure TWireOptions.Reset;
Begin
  AutoWidth := false;
  Width     := 1;
  Offset    := 0;
  PortId    := -1;
End;

Type
  TStringList = specialize TFPGList<String>;

Var
  AttrBuf       : TAttributeValues;
  CurrentModule : TModule;
  CurrentType   : TType;
  CurrentWire   : TSignal;
  WireOptions   : TWireOptions;
  CurrentCell   : TInstance;
  NewModule     : TModule;          // non-Nil if we are currently creating a module on the fly during its instantiation
  NewModules    : TStringList;      // list of modules created on the fly during their instantiation

Function GetType(Value:TValue):TType;
Begin
  if      Value is TValueInteger then Result := TypeInt
  else if Value is TValueString  then Result := TypeString
  else if Value is TValueBit     then Result := TypeBit
  else if Value is TValueVector  then Result := TType.Create('std_logic_vector',dirDown,(Value as TValueVector).FWidth-1,0)
  else if Value is TValueConcat  then Result := (Value as TValueConcat).GetType
  else if Value is TValueIndex   then Result := (Value as TValueIndex).GetType
  else if Value is TSignal       then Result := (Value as TSignal).FType
  else if Value is TPort         then Result := (Value as TSignal).FType
  else raise Exception.Create('Ths value type '+Value.ClassName+' is not yet supported');
End;

Function ILangValue2TValueVector(ILV:TValueString) : TValue;
Var St : String;
    P  : Integer;
    W  : Integer;
Begin
  St := ILV.FValue;
  P := Pos('''',St);
  if P = 0 then
    raise Exception.Create('Invalid format of value '''+St+'''');
  W := StrToInt(Copy(St,1,P-1));
  if W = 1 then
    Result := TValueBit.Create(St[P+1])
  else
    Result := TValueVector.Create(W,Copy(St,P+1,Length(St)));
End;

Function ReplaceModule(AName:String) : TModule;
Var OM,NM : TModule;
    M,I   : Integer;
Begin
  OM := ModuleList[AName];
  NM := TModule.Create(AName);
  // replace in all instances
  For M := 0 to ModuleList.Count-1 do
    Begin
      For I := 0 to ModuleList.Data[M].FInstances.Count-1 do
        Begin
          if ModuleList.Data[M].FInstances.Data[I].FModule = OM then
            ModuleList.Data[M].FInstances.Data[I].FModule := NM;
        End;
    End;
  // replace in module list
  OM.Free;
  ModuleList[AName] := NM;
  Result := NM;
End;

(*#include <list>
#include "ilang_frontend.h"
namespace ILANG_FRONTEND {
	RTLIL::Design *current_design;
	RTLIL::Module *current_module;
	RTLIL::Wire *current_wire;
	RTLIL::Memory *current_memory;
	RTLIL::Cell *current_cell;
	RTLIL::Process *current_process;
	std::vector<std::vector<RTLIL::SwitchRule*>*> switch_stack;
	std::vector<RTLIL::CaseRule*> case_stack;
	std::map<RTLIL::IdString, RTLIL::Const> attrbuf;
}
using namespace ILANG_FRONTEND;*)

const yymaxdepth = 100;

%}

%{
(*%name-prefix="rtlil_frontend_ilang_yy"

%union {
	char *string;
	int integer;
	RTLIL::Const *data;
	RTLIL::SigSpec *sigspec;
}*)
%}


%token <TValueString> TOK_ID TOK_VALUE TOK_STRING
%token <integer> TOK_INT
%token TOK_AUTOIDX TOK_MODULE TOK_WIRE TOK_WIDTH TOK_INPUT TOK_OUTPUT TOK_INOUT
%token TOK_CELL TOK_CONNECT TOK_SWITCH TOK_CASE TOK_ASSIGN TOK_SYNC
%token TOK_LOW TOK_HIGH TOK_POSEDGE TOK_NEGEDGE TOK_EDGE TOK_ALWAYS TOK_INIT
%token TOK_UPDATE TOK_PROCESS TOK_END TOK_INVALID TOK_EOL TOK_OFFSET
%token TOK_PARAMETER TOK_ATTRIBUTE TOK_MEMORY TOK_SIZE TOK_SIGNED

%type <TValue> sigspec sigspec_list
%type <integer> sync_type
%type <TValue> constant

%{
//%expect 0
//%debug
%}

%%

input:
	optional_eol {
                // before parsing the whole design
                AttrBuf := TAttributeValues.Create;
                NewModules := TStringList.Create;
	} design {
                // finished parsing the whole design
		if AttrBuf.Count <> 0 then
		  yyerror('dangling attribute');
                AttrBuf.Free;
	};

EOL:
	optional_eol TOK_EOL;

optional_eol:
	optional_eol TOK_EOL | /* empty */;

design:
	design module |
	design attr_stmt |
        design autoidx_stmt |
	/* empty */;

module:
	TOK_MODULE TOK_ID EOL {
                //WriteLn('Found module ',$2.FValue);
                if ModuleList.IndexOf($2.FValue) >= 0 then
                  Begin
                    if NewModules.IndexOf($2.FValue) >= 0 then
                      Begin
                        // we have an auto-generated module, and now we get the proper definition
                        // --> replace it; Note that this is very rude, because there are TInstance''s
                        // of this module with references to the ports and generics
                        WriteLn('Replacing auto-generated module ',$2.FValue,' with new declaration');
                        CurrentModule := ReplaceModule($2.FValue);
                        NewModules.Remove($2.FValue);
                      End
                    else
                      Begin
                        yyerror('ilang error: redefinition of module '+$2.FValue+'.');
                        Exit;
                      End;
                  End
                else
                  CurrentModule := TModule.Create($2.FValue);
                CurrentModule.FEntityAttributes.Free;
                CurrentModule.FEntityAttributes := AttrBuf;
		AttrBuf := TAttributeValues.Create;
                // save this module to list
                ModuleList[$2.FValue] := CurrentModule;
                $2.Free;
	} module_body TOK_END {
		// check that all attribute specifications were "consumed" by a following cell or wire
		if AttrBuf.Count <> 0 then
		  yyerror('dangling attribute');
	} EOL;

module_body:
	module_body module_stmt |
	/* empty */;

module_stmt:
	attr_stmt | wire_stmt | memory_stmt | cell_stmt | proc_stmt | conn_stmt;

attr_stmt:
	TOK_ATTRIBUTE TOK_ID constant EOL {
                //WriteLn('Found attribute, $1 = ',1,', $2 = ',$2.FValue,', $3 = ',$3.GetVerilogValue,', $4 = ',4);
                AttrBuf.Add(TAttribute.Create($2.FValue,GetType($3)),$3);
                $2.Free;
	};

autoidx_stmt:
        TOK_AUTOIDX TOK_INT EOL {
                // currently ignored
        };

wire_stmt:
	TOK_WIRE {
                WireOptions.Reset;
	} wire_options TOK_ID TOK_EOL {
                if (WireOptions.Offset = 0) and (WireOptions.Width = 1) then
                  CurrentType := TypeBit
                else
                  CurrentType := TType.Create('std_logic_vector',dirDown,WireOptions.Width+WireOptions.Offset-1,WireOptions.Offset);
                if WireOptions.PortId < 0 then
                  Begin
                    // internal signal
                    CurrentWire := TSignal.Create($4.FValue,CurrentType);
                    CurrentModule.AddSignal(CurrentWire,CurrentModule.FSignals.Count);
                  End
                else
                  Begin
                    // port of module
                    CurrentWire := TPort.Create($4.FValue,WireOptions.Dir,CurrentType);
                    CurrentModule.AddPort(CurrentWire as TPort,WireOptions.PortId);
                  End;
                CurrentWire.FAttributes.Free;
                CurrentWire.FAttributes := AttrBuf;
                //WriteLn('  Wire ',CurrentWire.WriteVerilogDeclaration);
                AttrBuf := TAttributeValues.Create;
                $4.Free;
	};

wire_options:
	wire_options TOK_WIDTH TOK_INT {
                WireOptions.Width := $3;
	} |
	wire_options TOK_OFFSET TOK_INT {
                WireOptions.Offset := $3;
	} |
	wire_options TOK_INPUT TOK_INT {
                WireOptions.PortId := $3;
                WireOptions.Dir    := dirIn;
	} |
	wire_options TOK_OUTPUT TOK_INT {
                WireOptions.PortId := $3;
                WireOptions.Dir    := dirOut;
	} |
	wire_options TOK_INOUT TOK_INT {
                WireOptions.PortId := $3;
                WireOptions.Dir    := dirInOut;
	} |
	/* empty */;

memory_stmt:
	TOK_MEMORY {
                yyerror('Memories not yet supported');
                // TODO
(*
		current_memory = new RTLIL::Memory;
		current_memory->attributes = attrbuf;
		attrbuf.clear();
*)
	} memory_options TOK_ID EOL {
(*
		if (current_module->memories.count($4) != 0)
			rtlil_frontend_ilang_yyerror(stringf("ilang error: redefinition of memory %s.", $4).c_str());
		current_memory->name = $4;
		current_module->memories[$4] = current_memory;
		free($4);
*)
	};

memory_options:
	memory_options TOK_WIDTH TOK_INT {
(*
		current_memory->width = $3;
*)
	} |
	memory_options TOK_SIZE TOK_INT {
(*
		current_memory->size = $3;
*)
	} |
	/* empty */;

cell_stmt:
	TOK_CELL TOK_ID TOK_ID EOL {
                if CurrentModule.FInstances.IndexOf($3.FValue) >= 0 then
                  yyerror('Cell instance '+$3.FValue+' already exists in the current module '+CurrentModule.FName);
                if ModuleList.IndexOf($2.FValue) >= 0 then
                  Begin
                    CurrentCell := TInstance.Create($3.FValue,ModuleList[$2.FValue]);
                    NewModule := Nil;   // = Nil --> using known module
                  End
                else
                  Begin
                    NewModule := TModule.Create($2.FValue);   // <> Nil --> using new module
                    NewModule.FEntityAttributes.Add(TAttribute.Create('pas_ilang_autogen',TypeInt),TValueInteger.Create(1));
                    WriteLn('Auto-generating module ',$2.FValue);
                    ModuleList.Add($2.FValue,NewModule);
                    NewModules.Add($2.FValue);  // store to list of auto-generated modules
                    CurrentCell := TInstance.Create($3.FValue,NewModule);
                  End;
                CurrentCell.FAttributes.Free;
                CurrentCell.FAttributes := AttrBuf;
                AttrBuf := TAttributeValues.Create;
                CurrentModule.AddInstance(CurrentCell,CurrentModule.FInstances.Count);
                $2.Free;
                $3.Free;
	} cell_body TOK_END EOL;

cell_body:
	cell_body TOK_PARAMETER TOK_ID constant EOL {
                if assigned(NewModule) then
                  NewModule.AddGeneric(TGeneric.Create($3.FValue,GetType($4),Nil),NewModule.FGenerics.Count);
                CurrentCell.SetGeneric($3.FValue,$4);
                $3.Free;
	} |
	cell_body TOK_PARAMETER TOK_SIGNED TOK_ID constant EOL {
                if assigned(NewModule) then
                  NewModule.AddGeneric(TGeneric.Create($4.FValue,GetType($5),Nil),NewModule.FGenerics.Count);
                  // TODO: signedness currently ignored
                CurrentCell.SetGeneric($4.FValue,$5);
                $4.Free;
	} |
	cell_body TOK_CONNECT TOK_ID sigspec EOL {
                // TODO: Yosys also uses these "connect" statements for "aliases", which occur
                // when wires are directly connected together. Unfortunately, "intermediate
                // wires" are not used, but only the very direct wire is used for all further
                // work. Although, these "intermediate wires" are preserved and the value of the
                // direct wire is assigned to them using such "connect" statements. This raises
                // two problems: 1) "intermediate wires" and their names are not seen any more,
                // and 2) the direction of this "connect" statement might be wrong, i.e. the left
                // side is the real driver, and the right side is the sink.
                // Therefore, we should check whether $3 or $4 is the driver, and if $3 is
                // the driver, swap $3 and $4. This has to be done in a post-processing step,
                // because here we don''t surely know all connections.
                if CurrentCell.FConnections.IndexOf($3.FValue) >= 0 then
                  yyerror('ilang error: redefinition of cell port '+$3.FValue);
                if assigned(NewModule) then
                  NewModule.AddPort(TPort.Create($3.FValue,dirIn(*unknown!*),GetType($4)),NewModule.FPorts.Count);
                CurrentCell.ConnectPort($3.FValue,$4);
                $3.Free;
	} |
	/* empty */;

proc_stmt:
	TOK_PROCESS TOK_ID EOL {
                yyerror('Processes not yet supported');
                // TODO
(*
		if (current_module->processes.count($2) != 0)
			rtlil_frontend_ilang_yyerror('ilang error: redefinition of process '+$2.FName+'.');
		current_process = new RTLIL::Process;
		current_process->name = $2;
		current_process->attributes = attrbuf;
		current_module->processes[$2] = current_process;
		switch_stack.clear();
		switch_stack.push_back(&current_process->root_case.switches);
		case_stack.clear();
		case_stack.push_back(&current_process->root_case);
		free($2);
*)
	} case_body sync_list TOK_END EOL;

switch_stmt:
	attr_list TOK_SWITCH sigspec EOL {
(*
		RTLIL::SwitchRule *rule = new RTLIL::SwitchRule;
		rule->signal = *$3;
		rule->attributes = attrbuf;
		switch_stack.back()->push_back(rule);
		attrbuf.clear();
		delete $3;
*)
	} switch_body TOK_END EOL;

attr_list:
	/* empty */ |
	attr_list attr_stmt;

switch_body:
	switch_body TOK_CASE {
(*
		RTLIL::CaseRule *rule = new RTLIL::CaseRule;
		switch_stack.back()->back()->cases.push_back(rule);
		switch_stack.push_back(&rule->switches);
		case_stack.push_back(rule);
*)
	} compare_list EOL case_body {
(*
		switch_stack.pop_back();
		case_stack.pop_back();
*)
	} |
	/* empty */;

compare_list:
	sigspec {
(*
		case_stack.back()->compare.push_back( *$1);
		delete $1;
*)
	} |
	compare_list ',' sigspec {
(*
		case_stack.back()->compare.push_back( *$3);
		delete $3;
*)
	} |
	/* empty */;

case_body:
	switch_stmt case_body |
	assign_stmt case_body |
	/* empty */;

assign_stmt:
	TOK_ASSIGN sigspec sigspec EOL {
(*
		case_stack.back()->actions.push_back(RTLIL::SigSig( *$2, *$3));
		delete $2;
		delete $3;
*)
	};

sync_list:
	sync_list TOK_SYNC sync_type sigspec EOL {
(*
		RTLIL::SyncRule *rule = new RTLIL::SyncRule;
		rule->type = RTLIL::SyncType($3);
		rule->signal = *$4;
		current_process->syncs.push_back(rule);
		delete $4;
*)
	} update_list |
	sync_list TOK_SYNC TOK_ALWAYS EOL {
(*
		RTLIL::SyncRule *rule = new RTLIL::SyncRule;
		rule->type = RTLIL::SyncType::STa;
		rule->signal = RTLIL::SigSpec();
		current_process->syncs.push_back(rule);
*)
	} update_list |
	/* empty */;

sync_type:
	TOK_LOW { (* $$ = RTLIL::ST0; *) } |
	TOK_HIGH { (* $$ = RTLIL::ST1; *) } |
	TOK_POSEDGE { (* $$ = RTLIL::STp; *) } |
	TOK_NEGEDGE { (* $$ = RTLIL::STn; *) } |
	TOK_EDGE { (* $$ = RTLIL::STe; *) };

update_list:
	update_list TOK_UPDATE sigspec sigspec EOL {
(*
		current_process->syncs.back()->actions.push_back(RTLIL::SigSig( *$3, *$4));
		delete $3;
		delete $4;
*)
	} |
	/* empty */;

constant:
	TOK_VALUE {
                //WriteLn('Found constant TOK_VALUE: ',$1.FValue);
                $$ := ILangValue2TValueVector($1);
	} |
	TOK_INT {
                //WriteLn('Found constant TOK_INT: ',$1);
                $$ := TValueInteger.Create($1);
	} |
	TOK_STRING {
                //WriteLn('Found constant TOK_STRING: ',$1.FValue);
                $$ := $1;
	};

sigspec:
	constant {
                //WriteLn('sigspec: const');
                $$ := $1;
	} |
	TOK_ID {
                if CurrentModule.FSignals.IndexOf($1.FValue) >= 0 then
                  $$ := CurrentModule.FSignals[$1.FValue]
                else if CurrentModule.FPorts.IndexOf($1.FValue) >= 0 then
                  $$ := CurrentModule.FPorts[$1.FValue]
                else
                  yyerror('ilang error: wire '+$1.FValue+' not found');
                //WriteLn('sigspec: TokID ',$1.FValue,', ',$$.ClassName);
	} |
	TOK_ID '[' TOK_INT ']' {
                if CurrentModule.FSignals.IndexOf($1.FValue) >= 0 then
                  $$ := CurrentModule.FSignals[$1.FValue]
                else if CurrentModule.FPorts.IndexOf($1.FValue) >= 0 then
                  $$ := CurrentModule.FPorts[$1.FValue]
                else
                  yyerror('Unknown signal '+$1.FValue);

                $$ := TValueIndex.Create($$,TValueInteger.Create($3));
(*
		if (current_module->wires.count($1) == 0)
			rtlil_frontend_ilang_yyerror(stringf("ilang error: wire %s not found", $1).c_str());
		RTLIL::SigChunk chunk;
		chunk.wire = current_module->wires[$1];
		chunk.offset = $3;
		chunk.width = 1;
		$$ = new RTLIL::SigSpec;
		$$->chunks.push_back(chunk);
		$$->width = 1;
		free($1);
*)
	} |
	TOK_ID '[' TOK_INT ':' TOK_INT ']' {
                if CurrentModule.FSignals.IndexOf($1.FValue) >= 0 then
                  $$ := CurrentModule.FSignals[$1.FValue]
                else if CurrentModule.FPorts.IndexOf($1.FValue) >= 0 then
                  $$ := CurrentModule.FPorts[$1.FValue]
                else
                  yyerror('Unknown signal '+$1.FValue);

                $$ := TValueIndex.Create($$,TRange.Create(dirDown,TValueInteger.Create($3),TValueInteger.Create($5)));
(*
		if (current_module->wires.count($1) == 0)
			rtlil_frontend_ilang_yyerror(stringf("ilang error: wire %s not found", $1).c_str());
		RTLIL::SigChunk chunk;
		chunk.wire = current_module->wires[$1];
		chunk.width = $3 - $5 + 1;
		chunk.offset = $5;
		$$ = new RTLIL::SigSpec;
		$$->chunks.push_back(chunk);
		$$->width = chunk.width;
		free($1);
*)
	} |
	'{' sigspec_list '}' {
		$$ := $2;
	};

sigspec_list:
	sigspec_list sigspec {
                $$ := TValueConcat.Create;
                //WriteLn('sigspec_list: $2 = ',$2.ClassName,': ',$2.GetVHDLValue);
                ($$ as TValueConcat).Add($2);
                //WriteLn('sigspec_list: $1 = ',$1.ClassName,': ',$1.GetVHDLValue);
                ($$ as TValueConcat).Copy($1 as TValueConcat);
                $1.Free;
(*
		$$ = new RTLIL::SigSpec;
		for (auto it = $2->chunks.begin(); it != $2->chunks.end(); it++) Begin
			$$->chunks.push_back( *it);
			$$->width += it->width;
		End;
		for (auto it = $1->chunks.begin(); it != $1->chunks.end(); it++) Begin
			$$->chunks.push_back( *it);
			$$->width += it->width;
		End;
		delete $1;
		delete $2;
*)
	} |
	/* empty */ {
                $$ := TValueConcat.Create;
	};

conn_stmt:
	TOK_CONNECT sigspec sigspec TOK_EOL {
		if AttrBuf.Count <> 0 then
		  yyerror('dangling attribute');
                CurrentModule.AddAssignment($2,$3);
	};

